/**
 * Munge the information generated by the abstract interpreter into the
 *  docfusion unified representation.
 *
 * Symbols always track the point of definition.
 **/

function munge(interpNode, modInfo, attrName) {
  var key;

  // if the underlying node was already munged into a symbol, use it.
  if ("node" in interpNode && "symbol" in interpNode.node) {
    return interpNode.node.symbol;
  }

  switch (interpNode.type) {
    case "function":
      // if it has anything in its prototype we call it a class...
      var hasProtoStuff = ("explicitProto" in interpNode);
      for (key in interpNode.proto.data) {
        hasProtoStuff = true;
        break;
      }
      if (hasProtoStuff)
        return mungeClass(interpNode, modInfo);
      // otherwise it's a straight-up function or method
      // (we could do this peeking or something clever, but let's just punt
      //  for now and figure if we are being evaluated in the context of a
      //  something that's naming us that we are a method...)
      if (attrName)
        return mungeMethod(interpNode, modInfo, attrName);
      else
        return mungeFunction(interpNode, modInfo);
      break;

    case "object":

      break;

    case "number":
    case "string":
    case "regexp":
    case "boolean":
    case "null":
      return mungeValue(interpNode, modInfo);
  }
}
exports.munge = munge;

function mungeNamespace(name, interpDict, modInfo) {
  var ns = new Namespace(name);
  for (var key in interpDict) {
    ns.childrenByName[key] = munge(interpDict[key], modInfo);
  }
  return ns;
}
exports.mungeNamespace = mungeNamespace;

function Namespace(name) {
  this.name = name;
  this.childrenByName = {};
}
Namespace.prototype = {
  kind: "namespace",
};

function ClassSym(name, modInfo) {
  this.name = name;
  this.module = modInfo;

  // all children by name
  this.childrenByName = {};
  // groups
  this.groups = {};
  // ungrouped children by name
  this.ungroupedChildrenByName = {};

  this.docStream = null;
  this.argTypes = null;
  this.retType = null;
}
ClassSym.prototype = {
  kind: "class",

  argTraverse: function(index) {
    if (!this.argTypes)
      return null;
    // XXX optional arguments should really come into play

  },
};

function mungeClass(interpNode, modInfo) {
  var csym = interpNode.node.symbol =
    new ClassSym(interpNode.node.name, modInfo);

  var pdata = interpNode.proto.data;
  for (var key in pdata) {
    csym.childrenByName[key] = munge(pdata[key], modInfo, key);
  }

  // See if the parse node has a doc node on it.
  if ("docNode" in interpNode.node)
    interpNode.node.docNode.linkToSym(csym);

  return csym;
}

function MethodSym(contextName, debugName, modInfo) {
  this.name = contextName;
  this.debugName = debugName;
  this.modInfo = modInfo;
}
MethodSym.prototype = {
  kind: "method",
};

function mungeMethod(interpNode, modInfo, attrName) {
  var sym = new MethodSym(attrName, interpNode.node.name, modInfo);

  // See if the parse node has a doc node on it.
  if ("docNode" in interpNode.node)
    interpNode.node.docNode.linkToSym(sym);

  return sym;
}

function FieldSym() {

}
FieldSym.prototype = {
  kind: "field",
};

function FunctionSym(name, modInfo) {
  this.name = name;
  this.modInfo = modInfo;

  this.docStream = null;
  this.argTypes = null;
  this.retType = null;
}
FunctionSym.prototype = {
  kind: "function",
};

function mungeFunction(interpNode, modInfo) {
  var sym = new FunctionSym(interpNode.node.name, modInfo);

  // See if the parse node has a doc node on it.
  if ("docNode" in interpNode.node)
    interpNode.node.docNode.linkToSym(sym);

  return sym;
}

function ValueSym(value, type, modInfo) {
  this.value = value;
  this.type = type;
}
ValueSym.prototype = {
  kind: "value",
};

function mungeValue(interpNode, modInfo) {
  return new ValueSym(interpNode.data, modInfo);
}

function Grouping() {

}
