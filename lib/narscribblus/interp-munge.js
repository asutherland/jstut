/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at:
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Messaging Code.
 *
 * The Initial Developer of the Original Code is
 *   The Mozilla Foundation
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Andrew Sutherland <asutherland@asutherland.org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
/**
 * Munge the information generated by the abstract interpreter into the
 *  docfusion unified representation.
 *
 * Symbols always track the point of definition.
 *
 * Names are tricky, we have a few varieties:
 * @itemize[
 *   @item{Accessible name via object initializer.}
 *   @item{Accessible name via assignment.}
 *   @item{Accessible name via function declaration syntax.}
 *   @item{Function names.}
 * ]
 *
 * The good news is that idioms that assign to prototype that don't involve
 *  mix-ins are pretty straightforward; the value being named is initially
 *  assigned to its proper name or equivalent embeded via object initializer.
 *  Helper OO functions / mix-ins can be more troublesome but tractable.  If
 *  the abstract interpreter can learn to not fear __proto__ we may also be
 *  good for explicit inheritance via prototype chain there.  Lexical/this
 *  OO may just be out of reach.
 *
 * In any event, if we track the 'names' a value is assigned to, we can probably
 *  figure out what is interesting after the fact.
 **/

require.def("narscribblus/interp-munge",
  [
    "exports",
    "narscribblus/render/html",
  ],
  function(
    exports,
    html
  ) {

var htmlEscapeText = html.htmlEscapeText;

/**
 * @protocol[Symish]
 *
 *
 */
var Symish = {
  name: null,
  life: null,
  kind: null,
  /**
   *
   * @args[
   *   @param[interpNode]
   *   @param[modInfo]
   *   @param[ownerStack]
   * ]
   * @return[null]
   */
  munge: function(interpNode, modInfo, ownerStack) {
  },
};

/**
 * Munging recursively traverses interp nodes, creating Symish nodes when they
 *  do not already exist.  The exception is pre-existing Namespace nodes; we
 *  don't attempt to traverse them since they should be read-only constructs
 *  we have already traversed.
 */
function munge(interpNode, modInfo, attrName, ownerStack) {
  var owner = ownerStack[ownerStack.length - 1];
  // we're at the top level if the only owner is the namespace
  var topLevel = ownerStack.length == 1;

  var key, sym;

  // if the underlying node was already munged into a symbol, use it.
  if ("node" in interpNode && "symbol" in interpNode.node) {
    sym = interpNode.node.symbol;
    sym.life.noteOwner(attrName, owner);
  }

  // check for recursion on the ownerStack...
  if (ownerStack.length > 1) {
    if (ownerStack.indexOf(owner) != ownerStack.length - 1) {
      console.error("recursion; good to know.");
      return sym;
    }
  }

  var life;
  if (!sym) {
    life = new LifeStory(modInfo,
                         ("node" in interpNode) ? interpNode.node.lineno : null);
    life.noteOwner(attrName, owner);

    switch (interpNode.type) {
      case "function":
        // if it has anything in its prototype we call it a class...
        var hasProtoStuff = ("explicitProto" in interpNode);
        for (key in interpNode.proto.data) {
          hasProtoStuff = true;
          break;
        }
        if (hasProtoStuff)
          sym = new ClassSym(interpNode.node.name, life);
        // otherwise it's a straight-up function or method
        // (we could do this peeking or something clever, but let's just punt
        //  for now and figure if we are being evaluated in the context of a
        //  something that's naming us that we are a method...)
        else if (!topLevel)
          sym = new MethodSym(attrName, interpNode.node.name, life);
        else
          sym = new FunctionSym(attrName, interpNode.node.name, life);
        break;

      case "object":
        sym = new ObjSym(attrName, life);
        break;

      case "number":
      case "string":
      case "regexp":
      case "boolean":
      case "null":
      case "unresolved":
      case "undefined":
        sym = new ValueSym(interpNode.value, interpNode.type, life);
        break;

      default:
      throw new Error("unsupported munge type: " + interpNode.type);
    }
    if ("node" in interpNode)
      interpNode.node.symbol = sym;
  }

  // See if the parse node has a doc node on it...
  if (!sym.docNode && ("node" in interpNode)) {
    if ("docNode" in interpNode.node)
      interpNode.node.docNode.linkToSym(sym);
    // failing that, the parser node should have an interpObj on it which
    //  references the originating attribute's parse node which could then have
    //  the docNode on it...
    else if (("interpObj" in interpNode.node) &&
             (interpNode.node.interpObj[0] === "attrval") &&
             ("docNode" in interpNode.node.interpObj[1].attr))
      interpNode.node.interpObj[1].attr.docNode.linkToSym(sym);
  }
  sym.munge(interpNode, modInfo, ownerStack);
  return sym;
}
exports.munge = munge;

function commonTraverseChild(name) {
  if (name in this.childrenByName)
    return this.childrenByName[name];
  return null;
}

/**
 * Namespaces are nominally immutable; we only create them once the abstract
 *  execution of a module has completed and no other modules should be poking
 *  at the module's namespaces (exports or global scope) after that point.
 *
 * @obeys[Symish HtmlNode]
 */
function Namespace(name, life) {
  this.name = name;
  this.life = life;
  this.childrenByName = {};
}
Namespace.prototype = {
  kind: "namespace",
  isType: false,
  traverseChild: commonTraverseChild,
  munge: function() {
    // If we are munged, that means someone required us and that reflects us
    //  into their world.  We currently don't really want to munge but...
    // XXX if modules are getting monkeypatched, we would want to re-munge this
    //  namespace to see if people changed anything.  But let's punt on that
    //  for now.
  },
  toHTMLString: function(options) {
    var bits = [];
    bits.push("<h2>" + htmlEscapeText(this.name) + "</h2>\n");
    bits.push("<dl>\n");
    for (var key in this.childrenByName) {
      bits.push("  <dt>" + htmlEscapeText(key) + "</dt>\n");
      var sym = this.childrenByName[key];
      bits.push("  <dd>" + sym.toHTMLString(options) + "</dd>\n");
    }
    bits.push("</dl>\n");
    return bits.join("");
  },
};

function mungeNamespace(name, interpDict, modInfo) {
  var life = new LifeStory(modInfo, 0);
  life.noteOwner(name, modInfo);
  var ns = new Namespace(name, life);

  var ownerStack = [ns];
  for (var key in interpDict) {
    ns.childrenByName[key] = munge(interpDict[key], modInfo, key, ownerStack);
  }
  return ns;
}
exports.mungeNamespace = mungeNamespace;

/**
 * An overkill location/usage marker whose rules are fused because this stuff
 *  is not particularly straightforward in JS.  Its knows/should know:
 * @itemize[
 *   @item{The point of definition for the thing.  Module name, line number.}
 *   @item{All owners...}
 * ]
 *
 * Everything is namespaced in terms of CommonJS modules.  Although the
 *  docfusion mechanism attempts to create conceptual namespaces, they are not
 *  known to us.
 */
function LifeStory(modInfo, line) {
  this.originModule = modInfo;
  this.originLine = line;
  this.originName = null;
  this.originOwner = null;
  /**
   * @listof[@list[
   *   @param["name" String]{
   *     Our name within the context of our owner.}
   *   @param["owner"]{
   *     The Sym-ish owner of us for whom we were a named child with the
   *     given name.
   *   }
   * ]]
   */
  this.owners = [];
}
LifeStory.prototype = {
  noteOwner: function(name, owner) {
    if (this.originName === null) {
      this.originName = name;
      this.originOwner = owner;
    }
    this.owners.push([name, owner]);
  },
};

function htmlifyDictSortingKeys(o, options) {
  var bits = [];
  var keys = [], key;
  for (key in o) {
    keys.push(key);
  }
  bits.push("<dl class='group'>\n");
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    var sym = o[key];
    bits.push("  <dt>" + htmlEscapeText(key) + "</dt>\n");
    bits.push("  <dd>" + sym.toHTMLString(options) + "</dd>\n");
  }
  bits.push("</dl>\n");
  return bits.join("");
}

function htmlifyKidsUsingGroups(container, options) {
  var s = htmlifyDictSortingKeys(container.ungroupedChildrenByName, options);
  for (var groupName in container.groups) {
    var group = container.groups[groupName];
    s += "<span class='groupName'>" + group.grouping.name + "</span>\n";
    s += htmlifyDictSortingKeys(group.childrenByName, options);
  }
  return s;
}

/**
 * Common logic for Class/Object symbols to perform grouping. refactoringsmell.
 */
function groupyLogic(container, key, sym) {
  // nop if the child was already known to us
  if (key in container.childrenByName)
    return;
  container.childrenByName[key] = sym;

  // the docNode should already be hooked up; see if it belongs to a group
  if (sym.docNode && sym.docNode.group) {
    var grouping = sym.docNode.group;
    var group;
    if (grouping.name in container.groups)
      group = container.groups[grouping.name];
    else
      group = container.groups[grouping.name] = new InstantiatedGroup(grouping);
    group.childrenByName[key] = sym;
  }
  else {
    container.ungroupedChildrenByName[key] = sym;
  }
}

function accessorLogic(container, accessors, modInfo) {
  var sym;
  for (var key in accessors) {
    // skip already-known getters.  because of the syntactic specialness
    //  of getters/setters (and this path is currently only for said syntax)
    //  there is no possibility for needing to track the life story across
    //  other sites.
    if (key in container.childrenByName)
      continue;

    var accNodes = accessors[key]; // [getter, setter]
    var getLife = null, setLife = null,
    getDocNode = null, setDocNode = null;
    if (accNodes[0]) {
      getLife = new LifeStory(modInfo, accNodes[0].lineno);
      getLife.noteOwner(key, container);
      if ("docNode" in accNodes[0])
        getDocNode = accNodes[0].docNode;
    }
    if (accNodes[1]) {
      setLife = new LifeStory(modInfo, accNodes[1].lineno);
      setLife.noteOwner(key, container);
      if ("docNode" in accNodes[1])
        setDocNode = accNodes[1].docNode;
    }
    sym = new GetterSetterSym(key, getLife, setLife,
                              getDocNode, setDocNode);
    groupyLogic(container, key, sym);
  }
}

/**
 *
 * @obeys[Symish HtmlNode]
 */
function ObjSym(name, life) {
  this.name = name;
  this.life = life;

  this.childrenByName = {};
  this.ungroupedChildrenByName = {};
  this.groups = {};

  this.docNode = null;
}
ObjSym.prototype = {
  kind: "object",
  isType: true,
  traverseChild: commonTraverseChild,
  munge: function(interpNode, modInfo, ownerStack) {
    var odata = interpNode.data, key, sym;
    var meStack = ownerStack.concat([this]);
    for (key in odata) {
      sym = munge(odata[key], modInfo, key, meStack);
      groupyLogic(this, key, sym);
    }

    if ("accessors" in interpNode)
      accessorLogic(this, interpNode.accessors, modInfo);
  },
  toHTMLString: function(options) {
    return htmlifyKidsUsingGroups(this, options);
  }
};

function commonTraverseArg(index) {
  if (!this.argTypes)
    return null;

  // If it's a numeric index, just try and directly index.
  // XXX optional arguments should really come into play
  if ((typeof(index) === "number") && index < this.argTypes.length) {
    return this.argTypes[index];
  }

  // If it's a string, try and find an argument by that name.
  if (typeof(index) === "string") {
    for (var i = 0; i < this.argTypes.length; i++) {
      var arg = this.argTypes[i];
      if (arg.name === index)
        return arg;
    }
  }

  return null;
}

/**
 * From a type perspective, a class is a (special) function that produces an
 *  instance of a type.  From a documentation perspective, we like them smooshed
 *  together / strongly associated.
 *
 * @obeys[Symish HtmlNode]
 */
function ClassSym(name,life) {
  this.name = name;
  this.life = life;

  // all children by name
  this.childrenByName = {};
  // groups
  this.groups = {};
  // ungrouped children by name
  this.ungroupedChildrenByName = {};

  // It's easiest to keep the stuff on our constructor in a subobject rather
  //  than messing with different attributes everywhere.
  this.staticBits = {
    childrenByName: {},
    groups: {},
    ungroupedChildrenByName: {},
  };

  this.docNode = null;
  this.argTypes = null;
}
ClassSym.prototype = {
  kind: "class",
  isType: true,

  toString: function() {
    return "[ClassSym " + this.name + "]";
  },

  // (implies constructor)
  traverseArg: commonTraverseArg,

  /**
   * @args[
   *   @param[name]
   *   @param[staticOrInstance #:optional @oneof["constructor" "instance"]]{
   *     Tells us whether the request is being made against the constructor
   *     or an instance of the type, if known.  Omit/pass undefined if you
   *     don't know and want us to check both places.
   *   }
   * ]
   */
  traverseChild: function(name, staticOrInstance) {
    // check the instance first
    if (staticOrInstance !== "constructor") {
      if (name in this.childrenByName)
        return this.childrenByName[name];
    }

    // check the constructor second
    if (staticOrInstance !== "instance") {
      if (name in this.staticBits.childrenByName)
        return this.staticBits.childrenByName[name];
    }

    // couldn't find it! so sad!
    return null;
  },

  munge: function(interpNode, modInfo, ownerStack) {
    var sdata = interpNode.data, pdata = interpNode.proto.data;
    var meStack = ownerStack.concat([this]);

    var key, sym;

    // - static
    for (key in sdata) {
      sym = munge(sdata[key], modInfo, key, meStack);
      groupyLogic(this.staticBits, key, sym);
    }

    // - instance
    for (key in pdata) {
      sym = munge(pdata[key], modInfo, key, meStack);
      groupyLogic(this, key, sym);
    }

    if ("accessors" in interpNode.proto)
      accessorLogic(this, interpNode.proto.accessors, modInfo);

    // docNode slurping
    if (this.docNode) {
      this.argTypes = this.docNode.gimmeArgTypes();
    }
  },

  briefTypeExpansionHTML: function(options) {
    // stolen from jsdoc.js::Func
    var s = "constructor(";
    if (this.args) {
      var argKids = this.argTypes;
      for (var i = 0; i < argKids.length; i++) {
        if (i)
          s += ", ";
        s += argKids[i].citeTypeHTML(options, true);
      }
    }
    s += ")";
    if (this.ret) {
      s += " => " + this.ret.citeTypeHTML(options, true);
    }
    return s;
  },

  detailedTypeExpansionHTML: function(options) {
    var s = "";
    if (this.args) {
      var argKids = this.argTypes;
      for (var i = 0; i < argKids.length; i++) {
        s += argKids[i].detailedTypeExpansionHTML(options);
      }
    }
    if (this.ret) {
      s += this.ret.toHTMLString(options);
    }
    return s;
  },

  toHTMLString: function(options) {
    var s = "<div class='class'>\n" +
      "  <h2>" + htmlEscapeText(this.name) + "</h2>\n";

    if (this.docNode)
      s += this.docNode.toHTMLString(options);

    if (("hierMode" in options) && options.hierMode != "nested")
      return s + "</div>";

    // - static stuff

    // - instance stuff
    s += htmlifyKidsUsingGroups(this, options);


    s += "</div>";

    return s;
  }
};

/**
 *
 * @obeys[Symish HtmlNode]
 */
function MethodSym(contextName, debugName, life) {
  this.name = contextName;
  this.debugName = debugName;
  this.life = life;

  this.docNode = null;
  this.argTypes = null;
}
MethodSym.prototype = {
  kind: "method",
  isType: false,
  munge: function(interpNode, modInfo, ownerStack) {
    // XXX people could decorate crap onto our function
    if (this.docNode) {
      this.argTypes = this.docNode.gimmeArgTypes();
    }
  },
  traverseArg: commonTraverseArg,
  toHTMLString: function(options) {
    if (this.docNode)
      return this.docNode.toHTMLString(options);
    else
      return "";
  }
};

/**
 * Symbol abstraction that fuses getters and setters into one since that
 *  is how we want to think of them, although one can be abset.
 */
function GetterSetterSym(name, getLife, setLife, getDocNode, setDocNode) {
  this.name = name;
  // the difference is boring enough that let's just favor the getter to be
  //  our representative to the world.
  this.life = getLife || setLife;
  this.getLife = getLife;
  this.setLife = setLife;
  this.getDocNode = getDocNode;
  this.setDocNode = setDocNode;
}
GetterSetterSym.prototype = {
  kind: "gettersetter",
  isType: false,
  munge: function() {
    throw new Error("getters/setters get munged by their owning objects");
  },
  toHTMLString: function(options) {
    var s = "<dl class='gettersetter'>\n";

    if (this.getLife) {
      s += "  <dt>getter</dt><dd>";
      if (this.getDocNode)
        s += this.getDocNode.toHTMLString(options);
      s += "</dd>\n";
    }
    if (this.setLife) {
      s += "  <dt>setter</dt><dd>";
      if (this.setDocNode)
        s += this.setDocNode.toHTMLString(options);
      s += "</dd>\n";
    }

    s += "</dl>\n";
    return s;
  }
};

/**
 *
 * @obeys[Symish HtmlNode]
 */
function FunctionSym(name, debugName, life) {
  this.name = name;
  this.debugName = debugName;
  this.life = life;

  this.docNode = null;
}
FunctionSym.prototype = {
  kind: "function",
  isType: false,
  munge: function(interpNode, modInfo, ownerStack) {
    // XXX people could decorate crap onto our function
  },

  traverseArg: function(index) {

  },

  toHTMLString: function(options) {

  },
};

/**
 * A non-Object terminal value; number, string, regex, boolean, etc.
 *
 * @obeys[Symish HtmlNode]
 */
function ValueSym(value, type, life) {
  this.value = value;
  this.type = type;
  this.life = life;

  this.docNode = null;
}
ValueSym.prototype = {
  kind: "value",
  isType: false,
  munge: function(interpNode, modInfo, ownerStack) {
    // nothing to munge about values
  },

  toHTMLString: function() {
    if (this.docNode)
      return this.docNode.toHTMLString(options);
    else
      return "";
  },
};

/**
 * An instantiated @xref{Grouping} that exists just so each container type can
 *  ensure that its list of children in that group does not get intertangled
 *  with other containers' caught up in the same @xref{Grouping}.
 */
function InstantiatedGroup(grouping) {
  this.grouping = grouping;
  this.childrenByName = {};
}
InstantiatedGroup.prototype = {
};

}); // end require.def
