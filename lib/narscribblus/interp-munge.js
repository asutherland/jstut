/**
 * Munge the information generated by the abstract interpreter into the
 *  docfusion unified representation.
 *
 * Symbols always track the point of definition.
 *
 * Names are tricky, we have a few varieties:
 * @itemize[
 *   @item{Accessible name via object initializer.}
 *   @item{Accessible name via assignment.}
 *   @item{Accessible name via function declaration syntax.}
 *   @item{Function names.}
 * ]
 *
 * The good news is that idioms that assign to prototype that don't involve
 *  mix-ins are pretty straightforward; the value being named is initially
 *  assigned to its proper name or equivalent embeded via object initializer.
 *  Helper OO functions / mix-ins can be more troublesome but tractable.  If
 *  the abstract interpreter can learn to not fear __proto__ we may also be
 *  good for explicit inheritance via prototype chain there.  Lexical/this
 *  OO may just be out of reach.
 *
 * In any event, if we track the 'names' a value is assigned to, we can probably
 *  figure out what is interesting after the fact.
 **/

var html = require("narscribblus/render/html");
var htmlEscapeText = html.htmlEscapeText;

/**
 * @protocol[Symish]
 */
var Symish = {
  name: null,
  life: null,
  kind: null,
  /**
   *
   * @args[
   *   @param[interpNode]
   *   @param[modInfo]
   *   @param[ownerStack]
   * ]
   * @return[null]
   */
  munge: function(interpNode, modInfo, ownerStack) {
  },
};

/**
 * Munging recursively traverses interp nodes, creating Symish nodes when they
 *  do not already exist.  The exception is pre-existing Namespace nodes; we
 *  don't attempt to traverse them since they should be read-only constructs
 *  we have already traversed.
 */
function munge(interpNode, modInfo, attrName, ownerStack) {
  var owner = ownerStack[ownerStack.length - 1];

  var key, sym;

  // if the underlying node was already munged into a symbol, use it.
  if ("node" in interpNode && "symbol" in interpNode.node) {
    sym = interpNode.node.symbol;
    sym.life.noteOwner(attrName, owner);
  }

  // check for recursion on the ownerStack...
  if (ownerStack.length > 1) {
    if (ownerStack.indexOf(owner) != ownerStack.length - 1) {
      console.error("recursion; good to know.");
      return sym;
    }
  }

  var life;
  if (!sym) {
    life = new LifeStory(modInfo,
                         ("node" in interpNode) ? interpNode.node.lineno : null);
    life.noteOwner(attrName, owner);

    switch (interpNode.type) {
      case "function":
        // if it has anything in its prototype we call it a class...
        var hasProtoStuff = ("explicitProto" in interpNode);
        for (key in interpNode.proto.data) {
          hasProtoStuff = true;
          break;
        }
        if (hasProtoStuff)
          sym = new ClassSym(interpNode.node.name, life);
        // otherwise it's a straight-up function or method
        // (we could do this peeking or something clever, but let's just punt
        //  for now and figure if we are being evaluated in the context of a
        //  something that's naming us that we are a method...)
        else if (attrName)
          sym = new MethodSym(attrName, interpNode.node.name, life);
        else
          sym = new FunctionSym(attrName, interpNode.node.name, life);
        break;

      case "object":
        sym = new ObjSym(attrName, life);
        break;

      case "number":
      case "string":
      case "regexp":
      case "boolean":
      case "null":
        sym = new ValueSym(interpNode.value, interpNode.type, life);
        break;

      default:
      throw new Error("unsupported munge type: " + interpNode.type);
    }
  }

  // See if the parse node has a doc node on it.
  if (!sym.docNode && ("node" in interpNode) && ("docNode" in interpNode.node))
    interpNode.node.docNode.linkToSym(csym);

  sym.munge(interpNode, modInfo, ownerStack);
  return sym;
}
exports.munge = munge;

/**
 * Namespaces are nominally immutable; we only create them once the abstract
 *  execution of a module has completed and no other modules should be poking
 *  at the module's namespaces (exports or global scope) after that point.
 *
 * @obeys[Symish HtmlNode]
 */
function Namespace(name, life) {
  this.name = name;
  this.life = life;
  this.childrenByName = {};
}
Namespace.prototype = {
  kind: "namespace",
  isType: false,
  munge: function() {
    // use mungeNamespace!
    throw new Error("do not directly invoke munge on a Namespace!");
  },
  toHTMLString: function(options) {
    var bits = [];
    bits.push("<h2>" + htmlEscapeText(this.name) + "</h2>\n");
    bits.push("<dl>\n");
    for (var key in this.childrenByName) {
      bits.push("  <dt>" + htmlEscapeText(key) + "</dt>\n");
      var sym = this.childrenByName[key];
      bits.push("  <dd>" + sym.toHTMLString(options) + "</dd>\n");
    }
    bits.push("</dl>\n");
    return bits.join("");
  },
};

function mungeNamespace(name, interpDict, modInfo) {
  var life = new LifeStory(modInfo, 0);
  life.noteOwner(name, modInfo);
  var ns = new Namespace(name, life);

  var ownerStack = [ns];
  for (var key in interpDict) {
    ns.childrenByName[key] = munge(interpDict[key], modInfo, key, ownerStack);
  }
  return ns;
}
exports.mungeNamespace = mungeNamespace;

/**
 * An overkill location/usage marker whose rules are fused because this stuff
 *  is not particularly straightforward in JS.  Its knows/should know:
 * @itemize[
 *   @item{The point of definition for the thing.  Module name, line number.}
 *   @item{All owners...}
 * ]
 *
 * Everything is namespaced in terms of CommonJS modules.  Although the
 *  docfusion mechanism attempts to create conceptual namespaces, they are not
 *  known to us.
 */
function LifeStory(modInfo, line) {
  this.originModule = modInfo;
  this.originLine = line;
  this.originName = null;
  this.originOwner = null;
  /**
   * @listof[@list[
   *   @param["name" String]{
   *     Our name within the context of our owner.}
   *   @param["owner"]{
   *     The Sym-ish owner of us for whom we were a named child with the
   *     given name.
   *   }
   * ]]
   */
  this.owners = [];
}
LifeStory.prototype = {
  noteOwner: function(name, owner) {
    if (this.originName === null) {
      this.originName = name;
      this.originOwner = owner;
    }
    this.owners.push([name, owner]);
  },
};

/**
 *
 * @obeys[Symish HtmlNode]
 */
function ObjSym(name, life) {
  this.name = name;
  this.life = life;
  this.childrenByName = {};
}
ObjSym.prototype = {
  kind: "object",
  isType: true,
  munge: function(interpNode, modInfo, ownerStack) {
    var odata = interpNode.data;
    var meStack = ownerStack.concat([this]);
    for (var key in odata) {
      this.childrenByName[key] = munge(odata[key], modInfo, key, meStack);
    }
  },
};

function htmlifyKidsUsingGroups(sym) {

}

/**
 * From a type perspective, a class is a (special) function that produces an
 *  instance of a type.  From a documentation perspective, we like them smooshed
 *  together / strongly associated.
 *
 * @obeys[Symish HtmlNode]
 */
function ClassSym(name,life) {
  this.name = name;
  this.life = life;

  // all children by name
  this.childrenByName = {};
  // groups
  this.groups = {};
  // ungrouped children by name
  this.ungroupedChildrenByName = {};

  this.docNode = null;
}
ClassSym.prototype = {
  kind: "class",
  isType: true,

  // (implies constructor)
  traverseArg: function(index) {
    if (!this.argTypes)
      return null;
    // XXX optional arguments should really come into play

  },

  // (could be constructor or type)
  traverseChild: function(name) {

  },

  munge: function(interpNode, modInfo, ownerStack) {
    var pdata = interpNode.proto.data;
    var meStack = ownerStack.concat([this]);

    // - static


    // - instance
    for (var key in pdata) {
      var sym = this.childrenByName[key] =
        munge(pdata[key], modInfo, key, meStack);
      // the docNode should already be hooked up; see if it belongs to a group
      if (sym.docNode && sym.docNode.group) {
        var grouping = sym.docNode.group;
        var group;
        if (grouping.name in this.groups)
          group = this.groups[grouping.name];
        else
          group = this.groups[grouping.name] = new InstantiatedGroup(grouping);
        group.childrenByName[key] = sym;
      }
      else {
        this.ungroupedChildrenByName[key] = sym;
      }
    }
  },

  toHTMLString: function(options) {
    var s = "<div class='class'>\n" +
      "  <h2>" + htmlEscapeText(this.name) + "</h2>\n";

    if (this.docNode)
      s += this.docNode.toHTMLString(options);

    if (("hierMode" in options) && options.hierMode != "nested")
      return s + "</div>";

    // - static stuff

    // - instance stuff


    s += "</div>";

    return s;
  }
};

/**
 *
 * @obeys[Symish HtmlNode]
 */
function MethodSym(contextName, debugName, life) {
  this.name = contextName;
  this.debugName = debugName;
  this.life = life;
}
MethodSym.prototype = {
  kind: "method",
  isType: false,
  munge: function(interpNode, modInfo, ownerStack) {
    // XXX people could decorate crap onto our function
  },
};

/**
 *
 * @obeys[Symish HtmlNode]
 */
function FieldSym() {

}
FieldSym.prototype = {
  kind: "field",
  isType: false,
};

/**
 *
 * @obeys[Symish HtmlNode]
 */
function FunctionSym(name, debugName, life) {
  this.name = name;
  this.debugName = debugName;
  this.life = life;

  this.docNode = null;
}
FunctionSym.prototype = {
  kind: "function",
  isType: false,
  munge: function(interpNode, modInfo, ownerStack) {
    // XXX people could decorate crap onto our function
  },
};

/**
 * A non-Object terminal value; number, string, regex, boolean, etc.
 *
 * @obeys[Symish HtmlNode]
 */
function ValueSym(value, type, life) {
  this.value = value;
  this.type = type;
  this.life = life;

  this.docNode = null;
}
ValueSym.prototype = {
  kind: "value",
  isType: false,
  munge: function(interpNode, modInfo, ownerStack) {
    // nothing to munge about values
  },

  toHTMLString: function() {
    if (this.docNode)
      return this.docNode.toHTMLString(options);
    else
      return "";
  },
};

/**
 * An instantiated @xref{Grouping} that exists just so each container type can
 *  ensure that its list of children in that group does not get intertangled
 *  with other containers' caught up in the same @xref{Grouping}.
 */
function InstantiatedGroup(grouping) {
  this.grouping = grouping;
  this.childrenByName = {};
}
InstantiatedGroup.prototype = {
};
