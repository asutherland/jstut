/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at:
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Messaging Code.
 *
 * The Initial Developer of the Original Code is
 *   The Mozilla Foundation
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Andrew Sutherland <asutherland@asutherland.org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Munge the information generated by the abstract interpreter into the
 *  docfusion unified representation.
 *
 * Symbols always track the point of definition.
 *
 * Names are tricky, we have a few varieties:
 * @itemize[
 *   @item{Accessible name via object initializer.}
 *   @item{Accessible name via assignment.}
 *   @item{Accessible name via function declaration syntax.}
 *   @item{Function names.}
 * ]
 *
 * The good news is that idioms that assign to prototype that don't involve
 *  mix-ins are pretty straightforward; the value being named is initially
 *  assigned to its proper name or equivalent embeded via object initializer.
 *  Helper OO functions / mix-ins can be more troublesome but tractable.  If
 *  the abstract interpreter can learn to not fear __proto__ we may also be
 *  good for explicit inheritance via prototype chain there.  Lexical/this
 *  OO may just be out of reach.
 *
 * In any event, if we track the 'names' a value is assigned to, we can probably
 *  figure out what is interesting after the fact.
 **/

require.def("narscribblus/interp-munge",
  [
    "exports",
    "narscribblus/render/html",
    "narscribblus/typerep",
    "narscribblus/mcstreamy",
  ],
  function(
    exports,
    html,
    $typerep,
    $docstreams
  ) {

var htmlEscapeText = html.htmlEscapeText;
var LifeStory = $typerep.LifeStory;

/**
 * @protocol[Symish]
 *
 *
 */
var Symish = {
  name: null,
  life: null,
  kind: null,
  /**
   *
   * @args[
   *   @param[interpNode]
   *   @param[modInfo]
   *   @param[ownerStack]
   * ]
   * @return[null]
   */
  munge: function(interpNode, modInfo, ownerStack) {
  },
};

/**
 * Munging recursively traverses interp nodes, creating typerep instances when
 *  they do not already exist.  The exception is pre-existing Namespace nodes;
 *  we don't attempt to traverse them since they should be read-only constructs
 *  we have already traversed.
 *
 * @return[@dict[
 *   @key[sym Typish]
 *   @key[grouping Grouping]
 * ]]
 */
function munge(interpNode, modInfo, attrName, ownerStack) {
  var owner = ownerStack[ownerStack.length - 1];
  // we're at the top level if the only owner is the namespace
  var topLevel = ownerStack.length == 1;

  var key, sym;

  // if the underlying node was already munged into a symbol, use it.
  if ("node" in interpNode && "symbol" in interpNode.node) {
    sym = interpNode.node.symbol;
    sym.life.noteOwner(attrName, owner);
  }

  // check for recursion on the ownerStack...
  if (ownerStack.length > 1) {
    if (ownerStack.indexOf(owner) != ownerStack.length - 1) {
      console.error("recursion; good to know.");
      return {sym: sym, grouping: null};
    }
  }

  var life, grouping = null;
  if (!sym) {
    life = new LifeStory(modInfo,
                         ("node" in interpNode) ? interpNode.node.lineno : null);
    life.noteOwner(attrName, owner);

    // Try and find a docNode so we can have it on hand when creating the
    //  type.
    var docNode, docBits;
    if ("docNode" in interpNode.node)
      docNode = interpNode.node.docNode;
    // failing that, the parser node should have an interpObj on it which
    //  references the originating attribute's parse node which could then have
    //  the docNode on it...
    else if (("interpObj" in interpNode.node) &&
             (interpNode.node.interpObj[0] === "attrval") &&
             ("docNode" in interpNode.node.interpObj[1].attr))
      docNode = interpNode.node.interpObj[1].attr.docNode;
    else
      docNode = null;

    switch (interpNode.type) {
      case "function":
        // if it has anything in its prototype we call it a class...
        var hasProtoStuff = ("explicitProto" in interpNode);
        for (key in interpNode.proto.data) {
          hasProtoStuff = true;
          break;
        }
        if (hasProtoStuff) {
          sym = new $typerep.ClassType(interpNode.node.name);
          sym.constructor = new $typerep.Constructor(sym.name, life);
          // try and pull the definition point of the prototype out of its
          //  object initializer if we can.
          var protoLife = life;
          // XXX no guarantee the object actually came from modInfo's module
          if (("node" in interpNode.proto) && interpNode.proto.node)
            protoLife = new LifeStory(modInfo, interpNode.proto.node.lineno);
          sym.prototype = new $typerep.ObjectType(sym.name, protoLife);
        }
        // otherwise it's a straight-up function or method
        // (we could do this peeking or something clever, but let's just punt
        //  for now and figure if we are being evaluated in the context of a
        //  something that's naming us that we are a method...)
        else if (!topLevel) {
          sym = new $typerep.Method(attrName, interpNode.node.name, life);
        }
        else {
          sym = new $typerep.FuncInstance(attrName, interpNode.node.name, life);
        }

        if (docNode) {
          docBits = $docstreams.snipeAndFilterTextStream(
                                  docNode.rawStream,
                                  $typerep.ArgList,
                                  $typerep.RetValDescriptor,
                                  $typerep.ThisDescriptor);
          sym.docStream = modInfo.formatTextStream(docBits[0]);
          sym.argList = docBits[1];
          sym.retDesc = docBits[2];
          // (This can make sense in the method case too, since sometimes we
          //  may assume something is a method when it is just a function
          //  hanging off the prototype for ease of access.)
          sym.thisDesc = docBits[3];

          grouping = docNode.grouping;
        }
        break;

      case "object":
        sym = new $typerep.GenericObj(attrName, life);
        if (docNode)
          sym.docStream = modInfo.formatTextStream(docNode.rawStream);
        break;

      case "number":
      case "string":
      case "regexp":
      case "boolean":
      case "null":
      case "unresolved":
      case "undefined":
        sym = new $typerep.Value(interpNode.value, interpNode.type, life);
        if (docNode) {
          sym.docStream = modInfo.formatTextStream(docNode.rawStream);
          grouping = docNode.grouping;
        }
        break;

      // the contents don't matter, just note that it's an array
      case "list":
        sym = new $typerep.Value([], "Array", life);
        if (docNode) {
          sym.docStream = modInfo.formatTextStream(docNode.rawStream);
          grouping = docNode.grouping;
        }
        break;

      case "activation":
        // we cannot/do not process activation records.
        return {sym: null, grouping: null};

      default:
        throw new Error("unsupported munge type: " + interpNode.type);
    }
    if ("node" in interpNode)
      interpNode.node.symbol = sym;
  }

  // XXX we used to do docNode processing here.  I am assuming this was not
  //  because docNodes would show up later in life, but simply an unintentional
  //  control flow artifact that never posed a problem because the docNode
  //  check would only try and do stuff if docNodes were not already assigned.
  //  Remove this comment when it turns out this comment is proved right or
  //  wrong.

  if (sym.kind in mungersByKind) {
    mungersByKind[sym.kind](sym, interpNode, modInfo, ownerStack);
  }

  return {sym: sym, grouping: grouping};
}
exports.munge = munge;

/**
 * Map the typerep's "kind" to the appropriate munging function.  The last
 *  implementation (Symish) put the munge methods on the class, but that was
 *  prior to unification with non-munging representations.
 */
var mungersByKind = {
  "object": function(sym, interpNode, modInfo, ownerStack) {
    var odata = interpNode.data, key, kidInfo;
    var meStack = ownerStack.concat([this]);
    for (key in odata) {
      kidInfo = munge(odata[key], modInfo, key, meStack);
      if (kidInfo)
        groupyLogic(sym, key, kidInfo);
    }

    if ("accessors" in interpNode)
      accessorLogic(sym, interpNode.accessors, modInfo);
  },

  "class": function(sym, interpNode, modInfo, ownerStack) {
    var sdata = interpNode.data, pdata = interpNode.proto.data;
    var meStack = ownerStack.concat([sym]);

    var key, kidInfo;

    // - static
    for (key in sdata) {
      kidInfo = munge(sdata[key], modInfo, key, meStack);
      if (kidInfo)
        groupyLogic(this.staticBits, key, kidInfo);
    }

    // - instance
    for (key in pdata) {
      kidInfo = munge(pdata[key], modInfo, key, meStack);
      if (kidInfo)
        groupyLogic(this, key, kidInfo);
    }

    if ("accessors" in interpNode.proto)
      accessorLogic(this, interpNode.proto.accessors, modInfo);

    // docNode slurping
    if (this.docNode) {
      this.argTypes = this.docNode.gimmeArgTypes();
    }
  },

  "method": function(sym, interpNode, modInfo, ownerStack) {
    // XXX people could decorate crap onto our function
  },

};

function commonTraverseChild(name) {
  if (name in this.childrenByName)
    return this.childrenByName[name];
  return null;
}

/**
 * Namespaces are nominally immutable; we only create them once the abstract
 *  execution of a module has completed and no other modules should be poking
 *  at the module's namespaces (exports or global scope) after that point.
 *
 * @obeys[Symish HtmlNode]
 */
function Namespace(name, life) {
  this.name = name;
  this.life = life;
  this.childrenByName = {};
}
Namespace.prototype = {
  kind: "namespace",
  isType: false,
  traverseChild: commonTraverseChild,
  munge: function() {
    // If we are munged, that means someone required us and that reflects us
    //  into their world.  We currently don't really want to munge but...
    // XXX if modules are getting monkeypatched, we would want to re-munge this
    //  namespace to see if people changed anything.  But let's punt on that
    //  for now.
  },
  toHTMLString: function(options) {
    var bits = [];
    bits.push("<h2>" + htmlEscapeText(this.name) + "</h2>\n");
    bits.push("<dl>\n");
    for (var key in this.childrenByName) {
      bits.push("  <dt>" + htmlEscapeText(key) + "</dt>\n");
      var sym = this.childrenByName[key];
      bits.push("  <dd>" + sym.toHTMLString(options) + "</dd>\n");
    }
    bits.push("</dl>\n");
    return bits.join("");
  },
};

function mungeNamespace(name, interpDict, modInfo) {
  var life = new LifeStory(modInfo, 0);
  life.noteOwner(name, modInfo);
  var ns = new Namespace(name, life);

  var ownerStack = [ns];
  for (var key in interpDict) {
    var munged = munge(interpDict[key], modInfo, key, ownerStack);
    if (munged)
      ns.childrenByName[key] = munged;
  }
  return ns;
}
exports.mungeNamespace = mungeNamespace;

function htmlifyDictSortingKeys(o, options) {
  var bits = [];
  var keys = [], key;
  for (key in o) {
    keys.push(key);
  }
  bits.push("<dl class='group'>\n");
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    var sym = o[key];
    bits.push("  <dt>" + htmlEscapeText(key) + "</dt>\n");
    bits.push("  <dd>" + sym.toHTMLString(options) + "</dd>\n");
  }
  bits.push("</dl>\n");
  return bits.join("");
}

function htmlifyKidsUsingGroups(container, options) {
  var s = htmlifyDictSortingKeys(container.ungroupedChildrenByName, options);
  for (var groupName in container.groups) {
    var group = container.groups[groupName];
    s += "<span class='groupName'>" + group.grouping.name + "</span>\n";
    s += htmlifyDictSortingKeys(group.childrenByName, options);
  }
  return s;
}

/**
 * Common logic for Class/Object symbols to perform grouping. refactoringsmell.
 */
function groupyLogic(container, key, kidInfo) {
  var sym = kidInfo.sym, grouping = kidInfo.grouping;

  // nop if the child was already known to us
  if (key in container.childrenByName)
    return;
  container.childrenByName[key] = sym;

  // the docNode should already be hooked up; see if it belongs to a group
  if (grouping) {
    var group;
    if (grouping.name in container.groups) {
      group = container.groups[grouping.name];
    }
    else {
      group = container.groups[grouping.name] =
        new $typerep.Group(grouping, grouping.docNode.formattedStream);
    }
    group.childrenByName[key] = sym;
  }
  else {
    container.ungroupedChildrenByName[key] = sym;
  }
}

function accessorLogic(container, accessors, modInfo) {
  var sym;
  for (var key in accessors) {
    // skip already-known getters.  because of the syntactic specialness
    //  of getters/setters (and this path is currently only for said syntax)
    //  there is no possibility for needing to track the life story across
    //  other sites.
    if (key in container.childrenByName)
      continue;

    var accNodes = accessors[key]; // [getter, setter]
    var getLife = null, setLife = null,
    getDocNode = null, setDocNode = null;
    if (accNodes[0]) {
      getLife = new LifeStory(modInfo, accNodes[0].lineno);
      getLife.noteOwner(key, container);
      if ("docNode" in accNodes[0])
        getDocNode = accNodes[0].docNode;
    }
    if (accNodes[1]) {
      setLife = new LifeStory(modInfo, accNodes[1].lineno);
      setLife.noteOwner(key, container);
      if ("docNode" in accNodes[1])
        setDocNode = accNodes[1].docNode;
    }
    sym = new GetterSetterSym(key, getLife, setLife,
                              getDocNode, setDocNode);
    groupyLogic(container, key, sym);
  }
}

/**
 *
 * @obeys[Symish HtmlNode]
 */
function ObjSym(name, life) {
  this.name = name;
  this.life = life;

  this.childrenByName = {};
  this.ungroupedChildrenByName = {};
  this.groups = {};

  this.docNode = null;
}
ObjSym.prototype = {
  kind: "object",
  isType: true,
  traverseChild: commonTraverseChild,
  toHTMLString: function(options) {
    var s = "<div class='class'>\n" +
      "  <h2>" + htmlEscapeText(this.name) + "</h2>\n";

    if (this.docNode)
      s += this.docNode.toHTMLString(options);

    if (("hierMode" in options) && options.hierMode != "nested")
      return s + "</div>";

    s += htmlifyKidsUsingGroups(this, options);


    s += "</div>";

    return s;
  }
};

function commonTraverseArg(index) {
  if (!this.argTypes)
    return null;

}

ClassSym.prototype = {
  briefTypeExpansionHTML: function(options) {
    // stolen from jsdoc.js::Func
    var s = "constructor(";
    if (this.args) {
      var argKids = this.argTypes;
      for (var i = 0; i < argKids.length; i++) {
        if (i)
          s += ", ";
        s += argKids[i].citeTypeHTML(options, true);
      }
    }
    s += ")";
    if (this.ret) {
      s += " => " + this.ret.citeTypeHTML(options, true);
    }
    return s;
  },

  detailedTypeExpansionHTML: function(options) {
    var s = "";
    if (this.args) {
      var argKids = this.argTypes;
      for (var i = 0; i < argKids.length; i++) {
        s += argKids[i].detailedTypeExpansionHTML(options);
      }
    }
    if (this.ret) {
      s += this.ret.toHTMLString(options);
    }
    return s;
  },

  toHTMLString: function(options) {
    var s = "<div class='class'>\n" +
      "  <h2>" + htmlEscapeText(this.name) + "</h2>\n";

    if (this.docNode)
      s += this.docNode.toHTMLString(options);

    if (("hierMode" in options) && options.hierMode != "nested")
      return s + "</div>";

    // - static stuff

    // - instance stuff
    s += htmlifyKidsUsingGroups(this, options);


    s += "</div>";

    return s;
  }
};

/**
 *
 * @obeys[Symish HtmlNode]
 */
function MethodSym(contextName, debugName, life) {
  this.name = contextName;
  this.debugName = debugName;
  this.life = life;

  this.docNode = null;
  this.thisTypeOverride = null;
  this.argTypes = null;
  this.retType = null;
}
MethodSym.prototype = {
  kind: "method",
  isType: false,
  traverseArg: commonTraverseArg,
  toHTMLString: function(options) {
    if (this.docNode)
      return this.docNode.toHTMLString(options);
    else
      return "";
  }
};

/**
 * Symbol abstraction that fuses getters and setters into one since that
 *  is how we want to think of them, although one can be abset.
 */
function GetterSetterSym(name, getLife, setLife, getDocNode, setDocNode) {
  this.name = name;
  // the difference is boring enough that let's just favor the getter to be
  //  our representative to the world.
  this.life = getLife || setLife;
  this.getLife = getLife;
  this.setLife = setLife;
  this.getDocNode = getDocNode;
  this.setDocNode = setDocNode;
}
GetterSetterSym.prototype = {
  kind: "gettersetter",
  isType: false,
  munge: function() {
    throw new Error("getters/setters get munged by their owning objects");
  },
  toHTMLString: function(options) {
    var s = "<dl class='gettersetter'>\n";

    if (this.getLife) {
      s += "  <dt>getter</dt><dd>";
      if (this.getDocNode)
        s += this.getDocNode.toHTMLString(options);
      s += "</dd>\n";
    }
    if (this.setLife) {
      s += "  <dt>setter</dt><dd>";
      if (this.setDocNode)
        s += this.setDocNode.toHTMLString(options);
      s += "</dd>\n";
    }

    s += "</dl>\n";
    return s;
  }
};

/**
 * A non-Object terminal value; number, string, regex, boolean, etc.
 *
 * @obeys[Symish HtmlNode]
 */
function ValueSym(value, type, life) {
  this.value = value;
  this.type = type;
  this.life = life;

  this.docNode = null;
}
ValueSym.prototype = {
  munge: function(interpNode, modInfo, ownerStack) {
    // nothing to munge about values
  },

  toHTMLString: function() {
    if (this.docNode)
      return this.docNode.toHTMLString(options);
    else
      return "";
  },
};

/**
 * An instantiated @xref{Grouping} that exists just so each container type can
 *  ensure that its list of children in that group does not get intertangled
 *  with other containers' caught up in the same @xref{Grouping}.
 */
function InstantiatedGroup(grouping) {
  this.grouping = grouping;
  this.childrenByName = {};
}
InstantiatedGroup.prototype = {
};

}); // end require.def
