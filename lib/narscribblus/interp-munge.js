/**
 * Munge the information generated by the abstract interpreter into the
 *  docfusion unified representation.
 *
 * Symbols always track the point of definition.
 *
 * Names are tricky, we have a few varieties:
 * @itemize[
 *   @item{Accessible name via object initializer.}
 *   @item{Accessible name via assignment.}
 *   @item{Accessible name via function declaration syntax.}
 *   @item{Function names.}
 * ]
 *
 * The good news is that idioms that assign to prototype that don't involve
 *  mix-ins are pretty straightforward; the value being named is initially
 *  assigned to its proper name or equivalent embeded via object initializer.
 *  Helper OO functions / mix-ins can be more troublesome but tractable.  If
 *  the abstract interpreter can learn to not fear __proto__ we may also be
 *  good for explicit inheritance via prototype chain there.  Lexical/this
 *  OO may just be out of reach.
 *
 * In any event, if we track the 'names' a value is assigned to, we can probably
 *  figure out what is interesting after the fact.
 **/

var html = require("narscribblus/render/html");
var htmlEscapeText = html.htmlEscapeText;

/**
 * @protocol[Symish]
 */
var Symish = {
  name: null,
  life: null,
  kind: null,
  /**
   *
   * @args[
   *   @param[interpNode]
   *   @param[modInfo]
   *   @param[ownerStack]
   * ]
   * @return[null]
   */
  munge: function(interpNode, modInfo, ownerStack) {
  },
};

/**
 * Munging recursively traverses interp nodes, creating Symish nodes when they
 *  do not already exist.  The exception is pre-existing Namespace nodes; we
 *  don't attempt to traverse them since they should be read-only constructs
 *  we have already traversed.
 */
function munge(interpNode, modInfo, attrName, ownerStack) {
  var owner = ownerStack[ownerStack.length - 1];
  // we're at the top level if the only owner is the namespace
  var topLevel = ownerStack.length == 1;

  var key, sym;

  // if the underlying node was already munged into a symbol, use it.
  if ("node" in interpNode && "symbol" in interpNode.node) {
    sym = interpNode.node.symbol;
    sym.life.noteOwner(attrName, owner);
  }

  // check for recursion on the ownerStack...
  if (ownerStack.length > 1) {
    if (ownerStack.indexOf(owner) != ownerStack.length - 1) {
      console.error("recursion; good to know.");
      return sym;
    }
  }

  var life;
  if (!sym) {
    life = new LifeStory(modInfo,
                         ("node" in interpNode) ? interpNode.node.lineno : null);
    life.noteOwner(attrName, owner);

    switch (interpNode.type) {
      case "function":
        // if it has anything in its prototype we call it a class...
        var hasProtoStuff = ("explicitProto" in interpNode);
        for (key in interpNode.proto.data) {
          hasProtoStuff = true;
          break;
        }
        if (hasProtoStuff)
          sym = new ClassSym(interpNode.node.name, life);
        // otherwise it's a straight-up function or method
        // (we could do this peeking or something clever, but let's just punt
        //  for now and figure if we are being evaluated in the context of a
        //  something that's naming us that we are a method...)
        else if (!topLevel)
          sym = new MethodSym(attrName, interpNode.node.name, life);
        else
          sym = new FunctionSym(attrName, interpNode.node.name, life);
        break;

      case "object":
        sym = new ObjSym(attrName, life);
        break;

      case "number":
      case "string":
      case "regexp":
      case "boolean":
      case "null":
        sym = new ValueSym(interpNode.value, interpNode.type, life);
        break;

      default:
      throw new Error("unsupported munge type: " + interpNode.type);
    }
  }

  // See if the parse node has a doc node on it.
  if (!sym.docNode && ("node" in interpNode) && ("docNode" in interpNode.node))
    interpNode.node.docNode.linkToSym(csym);

  sym.munge(interpNode, modInfo, ownerStack);
  return sym;
}
exports.munge = munge;

/**
 * Namespaces are nominally immutable; we only create them once the abstract
 *  execution of a module has completed and no other modules should be poking
 *  at the module's namespaces (exports or global scope) after that point.
 *
 * @obeys[Symish HtmlNode]
 */
function Namespace(name, life) {
  this.name = name;
  this.life = life;
  this.childrenByName = {};
}
Namespace.prototype = {
  kind: "namespace",
  isType: false,
  munge: function() {
    // use mungeNamespace!
    throw new Error("do not directly invoke munge on a Namespace!");
  },
  toHTMLString: function(options) {
    var bits = [];
    bits.push("<h2>" + htmlEscapeText(this.name) + "</h2>\n");
    bits.push("<dl>\n");
    for (var key in this.childrenByName) {
      bits.push("  <dt>" + htmlEscapeText(key) + "</dt>\n");
      var sym = this.childrenByName[key];
      bits.push("  <dd>" + sym.toHTMLString(options) + "</dd>\n");
    }
    bits.push("</dl>\n");
    return bits.join("");
  },
};

function mungeNamespace(name, interpDict, modInfo) {
  var life = new LifeStory(modInfo, 0);
  life.noteOwner(name, modInfo);
  var ns = new Namespace(name, life);

  var ownerStack = [ns];
  for (var key in interpDict) {
    ns.childrenByName[key] = munge(interpDict[key], modInfo, key, ownerStack);
  }
  return ns;
}
exports.mungeNamespace = mungeNamespace;

/**
 * An overkill location/usage marker whose rules are fused because this stuff
 *  is not particularly straightforward in JS.  Its knows/should know:
 * @itemize[
 *   @item{The point of definition for the thing.  Module name, line number.}
 *   @item{All owners...}
 * ]
 *
 * Everything is namespaced in terms of CommonJS modules.  Although the
 *  docfusion mechanism attempts to create conceptual namespaces, they are not
 *  known to us.
 */
function LifeStory(modInfo, line) {
  this.originModule = modInfo;
  this.originLine = line;
  this.originName = null;
  this.originOwner = null;
  /**
   * @listof[@list[
   *   @param["name" String]{
   *     Our name within the context of our owner.}
   *   @param["owner"]{
   *     The Sym-ish owner of us for whom we were a named child with the
   *     given name.
   *   }
   * ]]
   */
  this.owners = [];
}
LifeStory.prototype = {
  noteOwner: function(name, owner) {
    if (this.originName === null) {
      this.originName = name;
      this.originOwner = owner;
    }
    this.owners.push([name, owner]);
  },
};

function htmlifyDictSortingKeys(o, options) {
  var bits = [];
  var keys = [], key;
  for (key in o) {
    keys.push(key);
  }
  bits.push("<dl class='group'>\n");
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    var sym = o[key];
    bits.push("  <dt>" + htmlEscapeText(key) + "</dt>\n");
    bits.push("  <dd>" + sym.toHTMLString(options) + "</dd>\n");
  }
  bits.push("</dl>\n");
  return bits.join("");
}

function htmlifyKidsUsingGroups(container, options) {
  var s = htmlifyDictSortingKeys(container.ungroupedChildrenByName, options);
  for (var groupName in this.groups) {
    var group = this.groups[groupName];
    s += "<span class='groupName'>" + group.grouping.name + "</span>\n";
    s += htmlifyDictSortingKeys(group.childrenByName, options);
  }
  return s;
}

function groupyLogic(container, key, sym) {
  // nop if the child was already known to us
  if (key in container.childrenByName)
    return;
  container.childrenByName[key] = sym;

  // the docNode should already be hooked up; see if it belongs to a group
  if (sym.docNode && sym.docNode.group) {
    var grouping = sym.docNode.group;
    var group;
    if (grouping.name in container.groups)
      group = container.groups[grouping.name];
    else
      group = container.groups[grouping.name] = new InstantiatedGroup(grouping);
    group.childrenByName[key] = sym;
  }
  else {
    container.ungroupedChildrenByName[key] = sym;
  }
}

function accessorLogic(container, accessors, modInfo) {
  var sym;
  for (var key in accessors) {
    // skip already-known getters.  because of the syntactic specialness
    //  of getters/setters (and this path is currently only for said syntax)
    //  there is no possibility for needing to track the life story across
    //  other sites.
    if (key in container.childrenByName)
      continue;

    var accNodes = accessors[key]; // [getter, setter]
    var getLife = null, setLife = null,
    getDocNode = null, setDocNode = null;
    if (accNodes[0]) {
      getLife = new LifeStory(modInfo, accNodes[0].lineno);
      getLife.noteOwner(key, container);
      if ("docNode" in accNodes[0])
        getDocNode = accNodes[0].docNode;
    }
    if (accNodes[1]) {
      setLife = new LifeStory(modInfo, accNodes[1].lineno);
      setLife.noteOwner(key, container);
      if ("docNode" in accNodes[1])
        setDocNode = accNodes[1].docNode;
    }
    sym = new GetterSetterSym(key, getLife, setLife,
                              getDocNode, setDocNode);
    groupyLogic(container, key, sym);
  }
}

/**
 *
 * @obeys[Symish HtmlNode]
 */
function ObjSym(name, life) {
  this.name = name;
  this.life = life;

  this.childrenByName = {};
  this.ungroupedChildrenByName = {};
  this.groups = {};
}
ObjSym.prototype = {
  kind: "object",
  isType: true,
  munge: function(interpNode, modInfo, ownerStack) {
    var odata = interpNode.data, key, sym;
    var meStack = ownerStack.concat([this]);
    for (key in odata) {
      sym = munge(odata[key], modInfo, key, meStack);
      groupyLogic(this, key, sym);
    }

    if ("accessors" in interpNode)
      accessorLogic(this, interpNode.accessors, modInfo);
  },
  toHTMLString: function(options) {
    return htmlifyKidsUsingGroups(this, options);
  }
};

/**
 * From a type perspective, a class is a (special) function that produces an
 *  instance of a type.  From a documentation perspective, we like them smooshed
 *  together / strongly associated.
 *
 * @obeys[Symish HtmlNode]
 */
function ClassSym(name,life) {
  this.name = name;
  this.life = life;

  // all children by name
  this.childrenByName = {};
  // groups
  this.groups = {};
  // ungrouped children by name
  this.ungroupedChildrenByName = {};

  this.docNode = null;
}
ClassSym.prototype = {
  kind: "class",
  isType: true,

  // (implies constructor)
  traverseArg: function(index) {
    if (!this.argTypes)
      return null;
    // XXX optional arguments should really come into play

  },

  // (could be constructor or type)
  traverseChild: function(name) {

  },

  munge: function(interpNode, modInfo, ownerStack) {
    var pdata = interpNode.proto.data;
    var meStack = ownerStack.concat([this]);

    // - static


    // - instance
    for (var key in pdata) {
      var sym = munge(pdata[key], modInfo, key, meStack);
      groupyLogic(this, key, sym);
    }

    if ("accessors" in interpNode.proto)
      accessorLogic(this, interpNode.proto.accessors, modInfo);
  },

  toHTMLString: function(options) {
    var s = "<div class='class'>\n" +
      "  <h2>" + htmlEscapeText(this.name) + "</h2>\n";

    if (this.docNode)
      s += this.docNode.toHTMLString(options);

    if (("hierMode" in options) && options.hierMode != "nested")
      return s + "</div>";

    // - static stuff

    // - instance stuff
    s += htmlifyKidsUsingGroups(this, options);


    s += "</div>";

    return s;
  }
};

/**
 *
 * @obeys[Symish HtmlNode]
 */
function MethodSym(contextName, debugName, life) {
  this.name = contextName;
  this.debugName = debugName;
  this.life = life;

  this.docNode = null;
}
MethodSym.prototype = {
  kind: "method",
  isType: false,
  munge: function(interpNode, modInfo, ownerStack) {
    // XXX people could decorate crap onto our function
  },
  toHTMLString: function(options) {
    if (this.docNode)
      return this.docNode.toHTMLString(options);
    else
      return "";
  }
};

/**
 * Symbol abstraction that fuses getters and setters into one since that
 *  is how we want to think of them, although one can be abset.
 */
function GetterSetterSym(name, getLife, setLife, getDocNode, setDocNode) {
  this.name = name;
  // the difference is boring enough that let's just favor the getter to be
  //  our representative to the world.
  this.life = getLife || setLife;
  this.getLife = getLife;
  this.setLife = setLife;
  this.getDocNode = getDocNode;
  this.setDocNode = setDocNode;
}
GetterSetterSym.prototype = {
  kind: "gettersetter",
  isType: false,
  munge: function() {
    throw new Error("getters/setters get munged by their owning objects");
  },
  toHTMLString: function(options) {
    var s = "<dl class='gettersetter'>\n";

    if (this.getLife) {
      s += "  <dt>getter</dt><dd>";
      if (this.getDocNode)
        s += this.getDocNode.toHTMLString(options);
      s += "</dd>\n";
    }
    if (this.setLife) {
      s += "  <dt>setter</dt><dd>";
      if (this.setDocNode)
        s += this.setDocNode.toHTMLString(options);
      s += "</dd>\n";
    }

    s += "</dl>\n";
    return s;
  }
};

/**
 *
 * @obeys[Symish HtmlNode]
 */
function FunctionSym(name, debugName, life) {
  this.name = name;
  this.debugName = debugName;
  this.life = life;

  this.docNode = null;
}
FunctionSym.prototype = {
  kind: "function",
  isType: false,
  munge: function(interpNode, modInfo, ownerStack) {
    // XXX people could decorate crap onto our function
  },
  toHTMLString: function(options) {

  },
};

/**
 * A non-Object terminal value; number, string, regex, boolean, etc.
 *
 * @obeys[Symish HtmlNode]
 */
function ValueSym(value, type, life) {
  this.value = value;
  this.type = type;
  this.life = life;

  this.docNode = null;
}
ValueSym.prototype = {
  kind: "value",
  isType: false,
  munge: function(interpNode, modInfo, ownerStack) {
    // nothing to munge about values
  },

  toHTMLString: function() {
    if (this.docNode)
      return this.docNode.toHTMLString(options);
    else
      return "";
  },
};

/**
 * An instantiated @xref{Grouping} that exists just so each container type can
 *  ensure that its list of children in that group does not get intertangled
 *  with other containers' caught up in the same @xref{Grouping}.
 */
function InstantiatedGroup(grouping) {
  this.grouping = grouping;
  this.childrenByName = {};
}
InstantiatedGroup.prototype = {
};
