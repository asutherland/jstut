/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at:
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Messaging Code.
 *
 * The Initial Developer of the Original Code is
 *   The Mozilla Foundation
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Andrew Sutherland <asutherland@asutherland.org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Wmsy / protovis visualization of a pwomise hierarchy for debugging /
 *  understanding purposes.
 **/

define(
  [
    "wmsy/wmsy",
    "wmsy/opc/protovis",
    "narscribblus/utils/pwomise",
    "exports",
  ],
  function(
    $wmsy,
    pv,
    $pwomise,
    exports
  ) {

var wy = exports.wy = new $wmsy.WmsyDomain({id: "pwomise-vis",
                                            domain: "pwomise-debug",
                                            clickToFocus: true});

var RE_BORING_NAME = /^(?:auto|boring):/;

/**
 * Create a protovis pv.dom-style hierarchical representation.  Based on
 *  test-utils-pwomises' treeifyPromise method but somewhat better documented.
 *
 * Pwomises are currently backward chaining; every promise knows the promise it
 *  was dependent on.  Things are structured this way because the promise you
 *  are going to be holding onto and want to debug is always going to be the
 *  last promise in the chain; it won't be fulfilled (or rejected) until
 *  everything it is dependent on has happened.
 *
 * Furthermore, promises are inherently a single-ancestor type setup.  If you
 *  have two promises feeding into another promise, this happens as a result
 *  of helper logic that the debugging logic needs to be explicitly aware of.
 *  We handle this in all() and joinableGroup() by annotating subPromised
 *  attributes onto promises.
 */
function promiseToProtoVisRep(p, elideBoring) {
  var earliestTS = p.createdAt, latestTS = p.resolvedAt || p.createdAt;
  var seen = {};

  /**
   * @args[
   *   @param[p Promise]
   *   @param[kidRep #:optional ProtovisDomNode]
   * ]
   */
  function chewPromise(p, bounce) {
    // pierce promises generated by "when" to connect to the value/promise
    //  the "when" was waiting on.
    //if ("betterPromise" in p)
    //  p = p.betterPromise;

    if (p.createdAt < earliestTS)
      earliestTS = p.createdAt;
    if (p.resolvedAt !== null) {
      if (p.resolvedAt > latestTS)
        latestTS = p.resolvedAt;
    }
    else if (p.createdAt > latestTS) {
      latestTS = p.createdAt;
    }

    // every promise needs to map to a node.
    var dupe = p.id in seen;
    var self = new pv.Dom.Node({
      name: (p.what || "") + (p.whatSpecifically ? (": " + p.whatSpecifically)
                                                 : ""),
      createdAt: p.createdAt,
      resolvedAt: p.resolvedAt,
      dupe: dupe,
      reject: $pwomise.isRejected(p),
      bounce: bounce,
    });

    // don't recurse on dupes
    if (dupe)
      return self;
    seen[p.id] = true;

    // subPromised happens for explicitly wrap()ped promises, all() and
    //  joinableGroup().  We map them to parallel children, although for wrap
    //  this is not so important.
    // The attribute name is a bit dubious; we are conveying that these all
    //  fed into us.
    if ("promiseDeps" in p) {
      var kidIsBounce = false;
      for (var i = 0; i < p.promiseDeps.length; i++) {
        var dep = p.promiseDeps[i];
        if (dep === "bounce") {
          kidIsBounce = true;
          continue;
        }
        // ignore things that weren't deferreds.
        if (!$pwomise.isDeferredPromise(dep))
          continue;

        // If it's a boring kid and we're eliding, just add its children.
        if (elideBoring && dep.what && RE_BORING_NAME.test(dep.what)) {
          var kid = chewPromise(dep);
          while (kid.firstChild) {
            kid.firstChild.nodeValue.bounce = kidIsBounce;
            self.appendChild(kid.firstChild);
          }
        }
        else {
          self.appendChild(chewPromise(dep, kidIsBounce));
        }
        kidIsBounce = false;
      }
    }

    return self;
  }

  var rv = {
    nodes: chewPromise(p, false).nodes(),
    nodeCount: 0,
    earliestTS: earliestTS,
    latestTS: latestTS,
  };
  rv.nodeCount = rv.nodes.length;
  return rv;
}

/**
 * Pwomise visualization widget; based on the wmsy decision tree visualization
 *  widget (dusi-vis-decision-space.js).
 */
wy.defineWidget({
  name: "vis-pwomise-tree",
  constraint: {
    type: "vis-pwomise-tree",
  },
  structure: {
    kanvaz: {},
  },
  style: {
    root: [
      "background-color: white;",
      "border: 1px solid black;",
    ],
  },
  impl: {
    postInit: function() {
      var pvRep = promiseToProtoVisRep(this.obj, /* elide boring */ true);

      var NODE_HEIGHT = 14, HALF_HEIGHT = NODE_HEIGHT / 2;

      // required height is a function of the number of leaves
      var HEIGHT = pvRep.nodeCount * 14;
      var LEFT_MARGIN = 4, RIGHT_MARGIN = 4;
      // XXX perhaps we should just size to the window?
      var WIDTH = 1000 - LEFT_MARGIN - RIGHT_MARGIN;
      var TIME_WIDTH = 400, TIME_LEFT = WIDTH - TIME_WIDTH - RIGHT_MARGIN;

      var timeScale = pv.Scale.linear(pvRep.earliestTS, pvRep.latestTS)
                              .range(0, TIME_WIDTH);
      console.log(pvRep);

      var vis = this.vis = new pv.Panel()
        .width(WIDTH)
        .height(HEIGHT)
        .canvas(this.kanvaz_element)
        .margin(8)
        .left(LEFT_MARGIN)
        .right(RIGHT_MARGIN)
        .fillStyle("white");

      var layout = vis.add(pv.Layout.Indent)
        .nodes(pvRep.nodes)
        .breadth(NODE_HEIGHT)
        .depth(HALF_HEIGHT);

      // crib the style of the dendrogram example.
      layout.link.add(pv.Line)
        .strokeStyle("#cccccc")
        .lineWidth(1)
        .antialias(false);

      var colorMap = pv.Scale.ordinal("branch", "check", "result")
        .range("grey", "yellow", "green")
        .by(function(d) { return d.nodeValue.kind; });

      // create a panel so we get a box going all the way to the right...
      var cZebraOdd = pv.color("#eeeeee"), cZebraEven = null;
      var node = layout.node.add(pv.Panel)
        .top(function(n) { return n.y - HALF_HEIGHT; }) // magic number is what?
        .right(0) // span all the way to the right edge
        .height(NODE_HEIGHT)
        .strokeStyle(null)
        .fillStyle(function() {
                     return this.index % 2 ? cZebraOdd : cZebraEven;
                   });
      /*
        .events("all")
        .events("mousedown", toggle);
      function toggle(n) {
        console.log("toggling");
        n.toggle(pv.event.altKey);
        return layout.reset().root;
      };
       */

      // add a labeled dot to the left edge
      var cNodeDupe = pv.color("gray"),
          cNodeNormal = pv.color("lightgreen"),
          cNodeRejected = pv.color("red"),
          cNodeNeverResolved = pv.color("yellow");
      node.anchor("left").add(pv.Dot)
          .fillStyle(function(d) {
                       if (d.nodeValue.reject)
                         return cNodeRejected;
                       if (!d.nodeValue.resolvedAt)
                         return cNodeNeverResolved;
                       return d.nodeValue.dupe ? cNodeDupe : cNodeNormal;
                     })
          .strokeStyle("gray")
          .shape(function(d) {
                   if (d.nodeValue.bounce)
                     return "triangle";
                   else
                     return "circle";
                 })
        .anchor("right").add(pv.Label)
          .text(function(d) { return d.nodeValue.name; })
          .antialias(false);

      // add the time-span to the right.
      var cResolved = pv.color("lightgreen");
      var cUnresolved = pv.color("maroon");
      var cRejected = pv.color("lightred");
      var BAR_HEIGHT = 8, HALF_BAR_HEIGHT = BAR_HEIGHT / 2;
      node.add(pv.Bar)
        .top(HALF_HEIGHT - HALF_BAR_HEIGHT)
        .height(BAR_HEIGHT)
        .left(function(d) {
                return TIME_LEFT +
                  timeScale(d.nodeValue.createdAt.valueOf()) -
                  d.x;
              })
        .width(function(d) {
                 return Math.max(1,
                   (d.nodeValue.resolvedAt ?
                       timeScale(d.nodeValue.resolvedAt.valueOf()) :
                       TIME_WIDTH) -
                     timeScale(d.nodeValue.createdAt.valueOf()));
               })
        .fillStyle(function(d) {
                     return d.nodeValue.resolvedAt ? cResolved : cUnresolved;
                   });

      vis.render();
    },
  },
});

/**
 * Visualize a promise into the given document.
 */
exports.visualizePromise = function(doc, promise) {
  var bodyElem = doc.documentElement.children[1];
  var emitter = wy.wrapElement(bodyElem);
  emitter.emit({type: "vis-pwomise-tree", obj: promise},
               // make this be a pop-up so we can click away to get rid of it
               {
                 popup: {
                   position: {top: 10, left: 10},
                 },
               });
};

});
