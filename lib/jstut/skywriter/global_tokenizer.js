/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Ajax.org Code Editor (ACE).
 *
 * The Initial Developer of the Original Code is
 * Ajax.org Services B.V.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Fabian Jakobs <fabian AT ajax DOT org>
 *   Andrew Sutherland <asutherland@asutherland.org>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * This is a modified version of ace's background_tokenizer.js changed to
 *  support tokenizers that operate on the entirety of a program's source
 *  at once.  The basic idea is that we tell aware tokenizers about all the
 *  lines immediately prior to trying to get any answers out of them.
 *
 * I have also added some comments.
 **/

define(function(require, exports, module) {

var oop = require("pilot/oop");
var EventEmitter = require("pilot/event_emitter").EventEmitter;

/**
 * @typedef[TokenizedLine @dict[
 *   @key[tokens @listof[Token]]
 *   @key[state String]{
 *     Terminal state for the line.  Only matters for (otherwise) stateless
 *     line-based tokenizers.
 *   }
 *
 * ]]{
 *
 * }
 **/

/**
 * Support the jstut use-case by support parsing tokenizers that parse the
 *  document in its entirety with fallbacks to line-based tokenizers when
 *  the whole document parser falls down.  We also currently always defer
 *  to the line-based tokenizer for all editor indentation functionality and
 *  the like.
 *
 * The basic idea is that if the parser is able to parse the entire document,
 *  then we use it as the source of tokens.  If the parser chokes on the
 *  document, we use the parts it is able to provide us with, otherwise failing
 *  over to the line-based tokenizer for whatever it cannot provide us with.
 *
 * Our tokenized line status is accordingly stored in two tiers: `parsedLines`
 *  holds the lines as generated by the parser while `fallbackLines` holds the
 *  lines as generated by the fallback tokenizer.  We null out the `parsedLines`
 *  that become invalidated and use the fallback lines in that case.  Because
 *  the Document object very quickly starts generating unbounded update ranges
 *  (where lastRow === undefined) in complex cases, we don't need to deal with
 *  complex insertion/deletion scenarios.
 */
var GlobalFallbackTokenizer = function(tokenizer, editor) {
    this.running = false;
    /**
     * @listof[String]{
     *   The input source lines.
     * }
     */
    this.textLines = [];
    /**
     * How many lines in `textLines` last time we checked?  Lets us detect
     *  deltas (which we are not explicitly told about).
     */
    this.knownLineCount = 0;

    /** @listof[TokenizedLine] */
    this.parsedLines = [];
    /** @listof[TokenizedLine] */
    this.fallbackLines = [];
    /** the next line to be processed; equal to textLines.length when done */
    this.currentLine = 0;

    this._setTokenizer(tokenizer);

    // XXX debug inspection helper; no functional purpose
    window.tokenizer = this;

    var self = this;

    // A self-rescheduling timeout-based driver that processes as many sets of
    //  5 lines within >= 20ms as it can.  It reschedules itself ever 20 ms when
    //  it has not caught up with the visible area in the editor, and slows
    //  down to 100ms once it has.
    this.$worker = function() {
        if (!self.running) { return; }

        var workerStart = new Date();
        var startLine = self.currentLine;
        var textLines = self.textLines;

        var processedLines = 0;
        var lastVisibleRow = editor.getLastVisibleRow();

        while (self.currentLine < textLines.length) {
            self.fallbackLines[self.currentLine] =
              self.$tokenizeRows(self.currentLine, self.currentLine, false)[0];
            self.currentLine++;

            // only check every 5 lines
            processedLines += 1;
            if ((processedLines % 5 == 0) && (new Date() - workerStart) > 20) {
                self.fireUpdateEvent(startLine, self.currentLine-1);

                var timeout = self.currentLine < lastVisibleRow ? 20 : 100;
                self.running = setTimeout(self.$worker, timeout);
                return;
            }
        }

        self.running = false;

        self.fireUpdateEvent(startLine, textLines.length - 1);
    };
};

(function(){

    oop.implement(this, EventEmitter);

    this._setTokenizer = function(tokenizer) {
      if (tokenizer &&
          ("wholeDocumentParser" in tokenizer) &&
          tokenizer.wholeDocumentParser) {
        this.parser = tokenizer;
        this.tokenizer = tokenizer.fallbackTokenizer;
      }
      else {
        this.parser = null;
        this.tokenizer = tokenizer;
      }
      this.parserDirty = false;
    },

    this.setTokenizer = function(tokenizer) {
        this._setTokenizer(tokenizer);
        this.parsedLines = [];
        this.fallbackLines = [];

        this.start(0);
    };

    /**
     * Tell us about the array that holds the source lines.  This array can and
     *  will be mutated by code elsewhere.  We will be told about changes to
     *  the array by calls to `start`.
     */
    this.setLines = function(textLines) {
        this.textLines = textLines;
        this.knownLineCount = textLines.length;

        this.parsedLines = [];
        this.fallbackLines = [];

        this.stop();
    };

    /**
     * Tell listeners about our recently tokenized lines.
     */
    this.fireUpdateEvent = function(firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        console.log("tokenizer saying invalidating", firstRow, lastRow);
        this._dispatchEvent("update", {data: data});
    };

    /**
     * Notifies us that the document has changed at line `startRow` through
     *  `lastRow`.  Line based tokenizers effectively invalidate from startRow
     *  on.
     */
    this.start = function(startRow, lastRow) {
        if (this.parser) {
          this.parserDirty = true;
          if (lastRow === undefined) {
            // unbounded nukes make the parser forget about everything.
            this.parsedLines.splice(startRow, this.fallbackLines.length);
            this.parser.nukeState();
          }
          else {
            // net changes in document lines insert or remove nulls at startRow
            var delta = this.textLines.length - this.knownLineCount;

            if (delta || lastRow - startRow > 0)
              this.parser.nukeState();
            else
              this.parser.lineChanged(startRow, this.textLines[startRow]);

            if (delta > 0) {
              while (delta--)
                this.parsedLines.splice(startRow, 0, null);
            }
            else {
              this.parsedLines.splice(startRow, -delta);
            }
            this.knownLineCount = delta;

            // constrained variations just null out the affected lines so we
            //  look through them
            for (var i = startRow; i <= lastRow; i++) {
              this.parsedLines[i] = null;
            }

          }
        }

        this.currentLine = Math.min(startRow || 0, this.currentLine,
                                    this.textLines.length);

        // remove all cached items below this line
        this.fallbackLines.splice(this.currentLine, this.fallbackLines.length);

        this.stop();
        // pretty long delay to prevent the tokenizer from interfering with the user
        this.running = setTimeout(this.$worker, 700);
    };

    this.stop = function() {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    };

    this.getTokens = function(firstRow, lastRow, callback) {
        console.log("getting asked for", firstRow, lastRow);
        var rval = this.$tokenizeRows(firstRow, lastRow, true);
        callback(rval);
    };

    this.getState = function(row, callback) {
        callback(this.$tokenizeRows(row, row, false)[0].state);
    };

    this.$tokenizeRows = function(firstRow, lastRow, allowParser) {
        var rows = [];
        var sourceString = "";

        if (this.parser) {
          if (this.parserDirty) {
            var parsed = this.parser.parse(this.textLines);
            console.log("parser says it parsed up through",
                        parsed.firstBadLine);
            var parsedLines = this.parsedLines = [];
            for (var i = 0; i < parsed.firstBadLine; i++) {
              parsedLines.push(this.parser.getLineTokens(i));
            }
            this.parserDirty = false;
          }
        }

        // determine start state
        var state = "start";
        var doCache = false;
        if (firstRow > 0 && this.fallbackLines[firstRow - 1]) {
            state = this.fallbackLines[firstRow - 1].state;
            doCache = true;
        }

        for (var row=firstRow; row<=lastRow; row++) {
            var rowNeeded = true;
            if (allowParser &&
                this.parsedLines.length > row &&
                this.parsedLines[row]) {
              rows.push(this.parsedLines[row]);
              rowNeeded = false;
              sourceString += "P";
            }
            else {
              sourceString += "f";
            }
            if (!this.fallbackLines[row]) {
                var tokens = this.tokenizer.getLineTokens(this.textLines[row] || "", state);
                state = tokens.state;
                if (rowNeeded)
                  rows.push(tokens);

                if (doCache) {
                    this.fallbackLines[row] = tokens;
                }
            }
            else {
                var tokens = this.fallbackLines[row];
                state = tokens.state;
                if (rowNeeded)
                  rows.push(tokens);
            }
        }
        if (allowParser)
          console.log("source:", sourceString);
        return rows;
    };

}).call(GlobalFallbackTokenizer.prototype);

exports.GlobalFallbackTokenizer = GlobalFallbackTokenizer;
});
